// SpotifAI - StreamSmart: AWS Amplify Integration Ready
console.log('SpotifAI - StreamSmart: AWS Amplify Integration Loaded');

let currentSong = new Audio();
let songs;
let currFolder;
let currentSongIndex = 0;
let lastVolume = 1;

// Configuration for Amplify API (will be auto-generated)
let amplifyConfig = null;

// Check if Amplify is configured
async function checkAmplifyConfig() {
    try {
        // Try to load aws-exports.js (generated by Amplify CLI)
        const module = await import('./aws-exports.js');
        amplifyConfig = module.default;
        
        // Configure Amplify
        if (window.aws_amplify && window.aws_amplify.Amplify) {
            window.aws_amplify.Amplify.configure(amplifyConfig);
            console.log('‚úÖ Amplify configured successfully');
            return true;
        }
    } catch (error) {
        console.log('‚ÑπÔ∏è Amplify not configured, using direct API calls');
        return false;
    }
}

const modal = document.getElementById('ai-modal');
const modalTitle = document.getElementById('modal-title');
const modalText = document.getElementById('modal-text');
const modalCloseBtn = document.querySelector('.modal-close');

function showModal(title, text) {
    modalTitle.innerText = title;
    modalText.innerHTML = text;
    modal.style.display = 'flex';
}

function hideModal() {
    modal.style.display = 'none';
}

// Unified AI call function - works with or without Amplify backend
async function callAI(userContent, options = {}) {
    // Try Amplify API first
    if (amplifyConfig && window.aws_amplify && window.aws_amplify.API) {
        try {
            console.log('üöÄ Using Amplify API backend');
            const response = await window.aws_amplify.API.post('spotifaiAPI', '/ai', {
                body: { userContent, options }
            });
            return response.content;
        } catch (error) {
            console.warn('Amplify API failed, falling back to direct call:', error);
        }
    }

    // Fallback to direct Gemini API call
    console.log('üîó Using direct Gemini API call');
    return await callGeminiDirect(userContent, options);
}

// Direct Gemini API call (fallback)
async function callGeminiDirect(userContent, options = {}) {
    const { temperature = 0.7, max_tokens = 150 } = options;
    
    // Get API key from environment variables or show error
    const GEMINI_API_KEY = window.ENV?.GEMINI_API_KEY;

    if (!GEMINI_API_KEY) {
        throw new Error('‚ö†Ô∏è Gemini API key not configured. Please set GEMINI_API_KEY environment variable or configure Amplify backend.');
    }
    
    try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{ text: userContent }]
                }],
                generationConfig: {
                    temperature: temperature,
                    maxOutputTokens: max_tokens,
                }
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Gemini API Error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
        }

        const data = await response.json();
        return data.candidates[0].content.parts[0].text.trim();

    } catch (error) {
        console.error('Gemini API call failed:', error);
        throw error;
    }
}

async function detectSongMood(songTitle, buttonElement) {
    const originalButtonHTML = buttonElement.innerHTML;
    buttonElement.disabled = true;
    buttonElement.innerHTML = '<div class="spinner"></div>';

    showModal(`Analyzing "${songTitle}"`, "Please wait, the AI is thinking...");
    try {
        const prompt = `Analyze the mood of a song titled "${songTitle}". Respond with just 2-4 words describing the emotional mood (examples: "Upbeat and energetic", "Melancholic and reflective", "Romantic and dreamy").`;
        const mood = await callAI(prompt, { temperature: 0.5, max_tokens: 60 });
        showModal(`üé≠ Mood for "${songTitle}"`, `<p style="font-size: 1.2em; color: #1ed760;">${mood}</p>`);
    } catch (error) {
        console.error("Error detecting song mood:", error);
        showModal("Error", `Failed to detect mood: ${error.message}`);
    } finally {
        buttonElement.disabled = false;
        buttonElement.innerHTML = originalButtonHTML;
    }
}

async function explainSong(songTitle, buttonElement) {
    const originalButtonHTML = buttonElement.innerHTML;
    buttonElement.disabled = true;
    buttonElement.innerHTML = '<div class="spinner"></div>';

    showModal(`Explaining "${songTitle}"`, "Please wait, the AI is analyzing the title...");
    try {
        const prompt = `Based on the song title "${songTitle}", what might this song be about? Provide a short, engaging 2-3 sentence explanation about the potential themes, story, or emotions.`;
        const explanation = await callAI(prompt, { temperature: 0.7, max_tokens: 150 });
        showModal(`üí° About "${songTitle}"`, `<p>${explanation}</p>`);
    } catch (error) {
        console.error("Error explaining song:", error);
        showModal("Error", `Failed to get explanation: ${error.message}`);
    } finally {
        buttonElement.disabled = false;
        buttonElement.innerHTML = originalButtonHTML;
    }
}

// AI Smart Recommendations
const PLAYLIST_FOLDERS = [
    "assets/music/songs/ncs", "happy-hits", "top-global", "release-radar",
    "daily-mix-1", "discover-weekly", "chill-vibes",
    "indie-essentials", "hot-hits", "electronic-beats", "rock-classics",
    "jazz-lounge", "hip-hop-hits", "pop-anthems", "acoustic-sessions",
    "workout-energy", "focus-flow"
];

async function getAllSongTitles() {
    let allTitles = new Set();

    for (const folder of PLAYLIST_FOLDERS) {
        try {
            const path = folder.startsWith('assets/music/songs/') ? folder : `assets/music/songs/${folder}`;
            const response = await fetch(`/${path}/playlist.json`);
            if (response.ok) {
                const data = await response.json();
                data.songs.forEach(songFile => {
                    const title = decodeURIComponent(songFile).replace(/\.mp3$/, "");
                    allTitles.add(title);
                });
            }
        } catch (error) {
            console.warn(`Could not load playlist: ${folder}`, error);
        }
    }

    return Array.from(allTitles);
}

async function findSongLocation(songTitle) {
    for (const folder of PLAYLIST_FOLDERS) {
        try {
            const path = folder.startsWith('assets/music/songs/') ? folder : `assets/music/songs/${folder}`;
            const response = await fetch(`/${path}/playlist.json`);
            if (response.ok) {
                const data = await response.json();
                const foundSongFile = data.songs.find(songFile => {
                    const decodedTitle = decodeURIComponent(songFile).replace(/\.mp3$/, "");
                    return decodedTitle.toLowerCase() === songTitle.toLowerCase();
                });

                if (foundSongFile) {
                    return { folder: folder, fileName: decodeURIComponent(foundSongFile) };
                }
            }
        } catch (error) {
            console.warn(`Could not search playlist: ${folder}`, error);
        }
    }
    return null;
}

function renderRecommendations(recommendations) {
    const resultsContainer = document.getElementById('ai-recommendation-results');
    resultsContainer.innerHTML = '';

    if (!recommendations || recommendations.length === 0) {
        resultsContainer.innerHTML = '<p>No recommendations found for that query.</p>';
        return;
    }

    recommendations.forEach(song => {
        const item = document.createElement('div');
        item.className = 'recommendation-item';

        let playButtonHTML = '';
        if (song.isAvailable) {
            item.classList.add('playable');
            item.dataset.songTitle = song.title;
            playButtonHTML = `
                <div class="recommendation-play-btn">
                    <img src="/assets/images/svgs/play.svg" alt="Play">
                </div>
            `;
        }

        item.innerHTML = `
            <div class="song-details">
                <span class="song-title">${song.title}</span>
                <span class="song-artist">${song.artist || 'Unknown Artist'}</span>
            </div>
            ${playButtonHTML}
        `;
        resultsContainer.appendChild(item);
    });
}

async function handleRecommendationRequest() {
    const recommendationInput = document.getElementById('ai-recommendation-input');
    const recommendationBtn = document.getElementById('ai-recommendation-btn');
    const recommendationResults = document.getElementById('ai-recommendation-results');

    const query = recommendationInput.value.trim();
    if (!query) return;

    const originalButtonHTML = recommendationBtn.innerHTML;
    recommendationBtn.disabled = true;
    recommendationBtn.innerHTML = '<div class="spinner"></div>';
    recommendationResults.innerHTML = '<p>ü§ñ AI is searching for your vibe...</p>';

    try {
        const allSongTitles = await getAllSongTitles();

        const prompt = `You are a music expert. User wants: "${query}". 
        
From this list of available songs: ${allSongTitles.join(', ')}

Suggest 5 songs that match their request. Return ONLY a valid JSON array:
[
  {"title": "Song Name", "artist": "Artist Name", "isAvailable": true/false}
]

Rules:
- Set "isAvailable": true if the exact song title appears in the available list
- Set "isAvailable": false for suggestions not in the list
- Make up realistic artist names if unknown
- Focus on matching the mood/genre requested`;

        const response = await callAI(prompt, { temperature: 0.7, max_tokens: 400 });

        let recommendations = [];
        try {
            const jsonMatch = response.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
                recommendations = JSON.parse(jsonMatch[0]);
            } else {
                throw new Error('No valid JSON found in response');
            }
        } catch (parseError) {
            console.error("Failed to parse AI response:", parseError);
            console.error("Raw response:", response);
            throw new Error("AI returned an invalid format. Please try again.");
        }
        
        renderRecommendations(recommendations);

    } catch (error) {
        console.error("Error getting recommendations:", error);
        recommendationResults.innerHTML = `<p style="color: #ff4d4d;">Sorry, the AI had trouble: ${error.message}</p>`;
    } finally {
        recommendationBtn.disabled = false;
        recommendationBtn.innerHTML = originalButtonHTML;
    }
}

// All the existing music player functions (same as script-gemini.js)
function updatePlaylistHeader(title, description) {
    const titleEl = document.getElementById('current-playlist-title');
    const descEl = document.getElementById('current-playlist-description');

    if (titleEl) {
        titleEl.innerText = title || "Your Library";
    }
    if (descEl) {
        descEl.innerText = description || "";
    }
}

function secondsToMinutesSeconds(seconds) {
    if (isNaN(seconds) || seconds < 0) {
        return "00:00";
    }

    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);

    const formattedMinutes = String(minutes).padStart(2, '0');
    const formattedSeconds = String(remainingSeconds).padStart(2, '0');

    return `${formattedMinutes}:${formattedSeconds}`;
}

async function getSongs(folder) {
    const path = folder.startsWith('assets/music/songs/') ? folder : `assets/music/songs/${folder}`;
    currFolder = path;
    try {
        let response = await fetch(`/${path}/playlist.json`);
        if (!response.ok) {
            throw new Error(`Could not fetch playlist.json for /${path}`);
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error(error);
        return { title: "Error", description: "Could not load playlist.", songs: [] };
    }
}

const playMusic = (index, pause = false) => {
    if (index < 0 || index >= songs.length) {
        console.log("Reached end of playlist.");
        return;
    }
    currentSongIndex = index;
    const track = songs[currentSongIndex];
    currentSong.src = `/${currFolder}/` + encodeURIComponent(track);
 
    let play = document.querySelector(".playbtn");
 
    if (!pause) {
        currentSong.play();
        play.src = "/assets/images/svgs/pause.svg";
    }
    document.querySelector(".songinfo").innerHTML = track.replace(/\.mp3$/, "");
    document.querySelector(".songtime").innerHTML = "00:00 / 00:00";
}

function renderAndAttachListeners(songArray, playlistMetadata = null) {
    const songUL = document.querySelector(".songList ul");
    if (!songUL) {
        console.error("Song list UL element not found!");
        return;
    }
    songUL.innerHTML = "";

    for (const [index, song] of songArray.entries()) {
        const songName = song.replace(/\.mp3$/, "");
        
        // Get metadata for this song if available
        let artistName = "Artist Name";
        let duration = "3:00";
        
        if (playlistMetadata && playlistMetadata[index]) {
            const metadata = playlistMetadata[index];
            artistName = metadata.artist || "Unknown Artist";
            duration = metadata.duration || "3:00";
        }
        
        const li = document.createElement('li');
        li.dataset.track = song;
        li.className = 'songItem';
        li.style.position = 'relative';
        li.innerHTML = `
            <img class="invert" width="34" src="/assets/images/svgs/music.svg" alt="Music icon">
            <div class="info">
                <div class="song-title">${songName}</div>
                <div class="song-artist">${artistName}</div>
            </div>
            <div class="song-duration">${duration}</div>
            <div class="ai-actions">
                <button class="ai-btn mood-btn" title="Detect Song Mood">
                    <img src="/assets/images/svgs/mood.svg" alt="Detect Mood">
                </button>
                <button class="ai-btn explain-btn" title="Explain Song">
                    <img src="/assets/images/svgs/explain.svg" alt="Explain Song">
                </button>
            </div>
        `;

        li.addEventListener("click", (event) => {
            if (event.target.closest('.ai-btn')) {
                return;
            }
            playMusic(index);
        });

        li.querySelector('.mood-btn').addEventListener("click", (event) => {
            detectSongMood(songName, event.currentTarget);
        });

        li.querySelector('.explain-btn').addEventListener("click", (event) => {
            explainSong(songName, event.currentTarget);
        });

        songUL.appendChild(li);
    }
    
    // Add favorite buttons to all song items after rendering
    setTimeout(() => {
        if (window.userPlaylistManager) {
            window.userPlaylistManager.addFavoriteButtons();
        }
    }, 100);
}

async function main() {
    console.log('SpotifAI - StreamSmart initializing...');
    
    // Check Amplify configuration
    const amplifyConfigured = await checkAmplifyConfig();
    
    if (amplifyConfigured) {
        console.log('üöÄ Running with Amplify serverless backend');
    } else {
        console.log('üîó Running with direct API calls');
        console.log('üí° To use Amplify backend: follow AWS_AMPLIFY_GUIDE.md');
    }

    // Initialize music player
    const playlist = await getSongs("assets/music/songs/ncs");
    songs = playlist.songs.map(song => decodeURIComponent(song));
    updatePlaylistHeader(playlist.title, playlist.description);

    if (songs.length > 0) {
        playMusic(0, true);
    }
    
    renderAndAttachListeners(songs, playlist.metadata);

    // Music player controls
    let play = document.querySelector(".playbtn");
    play.addEventListener("click", () => {
        if (currentSong.paused) {
            currentSong.play();
            play.src = "/assets/images/svgs/pause.svg";
        } else {
            currentSong.pause();
            play.src = "/assets/images/svgs/play.svg";
        }
    });

    currentSong.addEventListener("timeupdate", () => {
        document.querySelector(".songtime").innerHTML = `${secondsToMinutesSeconds(currentSong.currentTime)} / ${secondsToMinutesSeconds(currentSong.duration)}`;
        document.querySelector(".circle").style.left = (currentSong.currentTime / currentSong.duration) * 100 + "%";
    });

    currentSong.addEventListener("ended", () => {
        if (currentSongIndex < songs.length - 1) {
            playMusic(currentSongIndex + 1);
        } else {
            document.querySelector(".playbtn").src = "/assets/images/svgs/play.svg";
        }
    });

    document.querySelector(".seekbar").addEventListener("click", (e) => {
        let percent = (e.offsetX / e.target.getBoundingClientRect().width) * 100;
        document.querySelector(".circle").style.left = percent + "%";
        currentSong.currentTime = ((currentSong.duration) * percent) / 100;
    });

    // Modal controls
    modalCloseBtn.addEventListener('click', hideModal);
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            hideModal();
        }
    });
    
    // Navigation
    document.querySelector(".hamburger").addEventListener("click", () => {
        document.querySelector(".left").style.left = "0";
    });

    document.querySelector(".close").addEventListener("click", () => {
        document.querySelector(".left").style.left = "-120%";
    });

    // AI Recommendations
    const recommendationInput = document.getElementById('ai-recommendation-input');
    const recommendationBtn = document.getElementById('ai-recommendation-btn');
    const recommendationResults = document.getElementById('ai-recommendation-results');

    recommendationBtn.addEventListener('click', handleRecommendationRequest);
    recommendationInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            handleRecommendationRequest();
        }
    });

    // Handle recommended song playback
    recommendationResults.addEventListener('click', async (e) => {
        const playableItem = e.target.closest('.recommendation-item.playable');
        if (!playableItem) return;

        const songTitleToPlay = playableItem.dataset.songTitle;
        const songLocation = await findSongLocation(songTitleToPlay);

        if (songLocation) {
            const playlist = await getSongs(songLocation.folder);
            songs = playlist.songs.map(song => decodeURIComponent(song));
            updatePlaylistHeader(playlist.title, playlist.description);
            renderAndAttachListeners(songs, playlist.metadata);

            const songIndex = songs.findIndex(s => s.toLowerCase() === songLocation.fileName.toLowerCase());
            if (songIndex !== -1) {
                playMusic(songIndex);
            }
        }
    });
    
    // Previous/Next controls
    document.getElementById("previous").addEventListener("click", () => {
        if (currentSongIndex > 0) {
            playMusic(currentSongIndex - 1);
        }
    });

    document.getElementById("next").addEventListener("click", () => {
        if (currentSongIndex < songs.length - 1) {
            playMusic(currentSongIndex + 1);
        }
    });

    // Volume controls
    document.querySelector(".range").getElementsByTagName("input")[0].addEventListener("change", (e) => {
        const newVolume = parseInt(e.target.value) / 100;
        currentSong.volume = newVolume;
        if (newVolume === 0) {
            document.querySelector(".volume>img").src = "/assets/images/svgs/mute.svg";
        } else {
            document.querySelector(".volume>img").src = "/assets/images/svgs/volume.svg";
        }
    });

    document.querySelector(".volume>img").addEventListener("click", (e) => { 
        const volumeIcon = e.target;
        const volumeSlider = document.querySelector(".range input");
        if (currentSong.volume > 0) {
            lastVolume = currentSong.volume;
            volumeIcon.src = "/assets/images/svgs/mute.svg";
            currentSong.volume = 0;
            volumeSlider.value = 0;
        } else {
            volumeIcon.src = "/assets/images/svgs/volume.svg";
            currentSong.volume = lastVolume;
            volumeSlider.value = lastVolume * 100;
        }
    });

    // Playlist cards
    Array.from(document.getElementsByClassName("card")).forEach(card => {
        card.addEventListener("click", async (event) => {
            let folder = event.currentTarget.dataset.folder;
            if (!folder) return;

            const playlist = await getSongs(folder);
            songs = playlist.songs.map(song => decodeURIComponent(song));
            updatePlaylistHeader(playlist.title, playlist.description);
            renderAndAttachListeners(songs, playlist.metadata);
    
            if (songs.length > 0) {
                playMusic(0);
            }
        });
    });

    console.log('üéµ SpotifAI - StreamSmart ready!');
    if (amplifyConfigured) {
        console.log('‚úÖ AI features running on AWS Amplify serverless backend');
    } else {
        console.log('‚ö†Ô∏è AI features using direct API calls (add Amplify for production)');
    }
    
    // Expose functions globally for user playlist system
    window.songs = songs;
    window.currFolder = currFolder;
    window.updatePlaylistHeader = updatePlaylistHeader;
    window.renderAndAttachListeners = renderAndAttachListeners;
    window.playMusic = playMusic;
}

main();